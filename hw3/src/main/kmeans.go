package main

import "os"
import "fmt"
import "math"
import "mapreduce"
import "strings"
import "strconv"
//import "math/rand"
import "bufio"
import "log"

// A structure representing a single 2-D point
type Point struct {
	x float64
	y float64
}

// The most recent centerpoints of each cluster
var clusters []Point


// usual 2-D Euclidian distance
func distance(p1 Point, p2 Point) float64 {
	first := math.Pow(float64(p2.x-p1.x), 2)
	second := math.Pow(float64(p2.y-p1.y), 2)
	return math.Sqrt(first + second)
}

// complete an iteration of the algorithm by loading
// the results from the reduce phase, which indicates
// the new centerpoint of each cluster. These results
// are then used as the input to the subsequent phase.
// This function expects that the Reduce function
// will emit its results as a string consisting of
// three space-separated fields: the x-centerpoint,
// the y-centerpoint, and the cluster number, for example:
//     0.34344 0.988426 4
func loadClusters(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatal("Can't open final result file, ",filename)
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		text:=scanner.Text()
		words := strings.Split(text, " ")
		x,err:=strconv.ParseFloat(words[1],64)
		if err!=nil {
			log.Fatalf("Can't parse float %s, skipping %s\n", words[1])
		}
		y,err:=strconv.ParseFloat(words[2],64)
		if err!=nil {
			log.Fatalf("Can't parse float %s, skipping\n", words[2])
		}
		cluster,err:=strconv.Atoi(words[3])
		if err!=nil {
			log.Fatalf("Can't parse float %s, skipping\n", words[2])
		}
		clusters[cluster]=Point{x,y}
	}
}

// our simplified version of MapReduce does not supply a
// key to the Map function, as in the paper; only a value,
// which is a part of the input file content. the return
// value should be a list of key/value pairs, each represented
// by a mapreduce.KeyValue.
func Map(value string) []mapreduce.KeyValue {
    output := []mapreduce.KeyValue{}
    // iterate over each line in string
    scanner := bufio.NewScanner(strings.NewReader(value))
    for scanner.Scan() {
        // split each line into list so we can isolate the x and y for the point
        pointList := strings.Fields(scanner.Text())
        x, _ := strconv.ParseFloat(pointList[0], 16)
        y, _ := strconv.ParseFloat(pointList[1], 16)
        point := Point{x, y}
        // find closest cluster to point
        shortestDist := -1.0
        var cluster int
        for i, centerPoint := range clusters {
            dist := distance(point, centerPoint)
            if shortestDist == -1.0 {
                cluster = i
                shortestDist = dist
            } else if dist < shortestDist {
                shortestDist = dist
                cluster = i
            }
        }
        // add key val
        val := pointList[0] + " " + pointList[1]
        keyVal := mapreduce.KeyValue{Key: strconv.Itoa(cluster), Value: val}
        output = append(output, keyVal)
    }
    return output
}

// called once for each key generated by Map, with a list
// of that key's associate values. should return a single
// output value for that key.
// The output value should be a string consisting
// of three space-separated numbers, as described
// in the comment for loadClusters.
func Reduce(key string, values []string) string {
    var xCenter float64
    var yCenter float64
    // add all points together
    for _, point := range values {
        pointList := strings.Fields(point)
        x, _ := strconv.ParseFloat(pointList[0], 16)
        y, _ := strconv.ParseFloat(pointList[1], 16)
        xCenter += x
        yCenter += y
    }
    // calculate average
    centerX := fmt.Sprintf("%f", xCenter / float64(len(values)))
    centerY := fmt.Sprintf("%f", yCenter / float64(len(values)))
    return centerX + " " + centerY + " " + key

}

func main() {
	if len(os.Args) != 6 {
		fmt.Printf("%s: Invalid invocation %s\n", os.Args[0])
	} else {
		clusterCount, err := strconv.Atoi(os.Args[4])
		if err != nil {
			log.Fatalf("Bad cluster count: %s\n", os.Args[4])
		}
		iterationCount, err := strconv.Atoi(os.Args[5])
		if err != nil {
			log.Fatalf("Bad iteration count: %s\n", os.Args[5])
		}
		maxClusterCount := clusterCount
		for clusterCount > 0 {
			clusters = append(clusters, Point{float64(clusterCount)/float64(maxClusterCount), float64(clusterCount)/float64(maxClusterCount)})
			clusterCount--
		}
		for iterationCount > 0 {
			if os.Args[1] == "master" {
				if os.Args[3] == "sequential" {
					mapreduce.RunSingle(5, 3, os.Args[2], Map, Reduce)
				} else {
					mr := mapreduce.MakeMapReduce(5, 3, os.Args[2], os.Args[3])
					// Wait until MR is done
					<-mr.DoneChannel
				}
			} else if os.Args[1] == "worker" {
				mapreduce.RunWorker(os.Args[2], os.Args[3], Map, Reduce, 100)
			} else {
				log.Fatalf("Unexpected input")
			}
			iterationCount--
			loadClusters(mapreduce.FinalName(os.Args[2]))
		}
	}
}
